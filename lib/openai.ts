import { LifeData } from "@/app/myself/page";
import OpenAI from "openai";
import { ChatCompletionMessageParam, ChatCompletionTool } from "openai/resources/index";
import { zodResponseFormat } from 'openai/helpers/zod';
import { z } from "zod";
import { ProjectsData } from "@/app/projects/page";

// OpenAI client initialization
const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY as string, // Type assertion for env variable
  dangerouslyAllowBrowser: true,
});

// Type for function parameters
interface LifeDataParams {
  data: string;
}

// Function to retrieve life data
function getKikiLifeData(data: string): string {
  const dataInfo = {
    data,
    content: LifeData[`${data}.tsx`] || {}, // Ensure valid object access
  };

  return JSON.stringify(dataInfo);
}

function getKikiProjectsData(data: string): string {
  const dataInfo = {
    data,
    content: ProjectsData[`${data}`] || {}, // Ensure valid object access
  };

  return JSON.stringify(dataInfo);
}

function getAboutKiki(): string {
  return `
  I'm Ekky Mulia Lasardi (Ekky/Kiki) (Male, Birthdate May 28 2004) ( Hobby: Playing Stretegy games and gym)
  A Software Engineer based in Jakarta,
  mainly focused on Fullstack and Generative AI.
  Professional Summary
  Specializing in full-stack development and AI-driven solutions, I have over a year of remote freelancing experience, completing more than 20 projects that enhance user satisfaction and performance. Currently, I am pursuing a Bachelor’s degree in Software Engineering Technology at IPB University, where I lead the Google Developer Group on campus and mentor students in web development.
  My achievements include developing an award-winning AI integrated help center system and an AI self-evaluating examination system recognized in competitions hosted by the Indonesian Ministry of Education, Culture, Research, and Technology. I hold certifications in DevOps, Cloud Technology, and Front-End Development, showcasing my commitment to innovation in technology.`
}

function getWebsiteFAQ(): string {
  return `
  This website was built using React (Next.js), Tailwind CSS, ShadCN, and MagicUI. It was deployed on Vercel and created in just 4 days by Ekky. The website’s data is stored in JSON format, used as reusable components across pages, and supplied to AI through function calls to minimize prompt tokens, ensuring that only relevant and useful data is utilized, as determined autonomously by the LLM—making it different from other chatbots.

  Another distinguishing feature is the use of pre-determined prompt/button choices. These buttons were designed to help guests ask more in-depth questions about Kiki, while ensuring the data is consistent with the data bank. What makes it unique is that the pre-determined prompts/buttons are dynamically generated by the LLM based on the guest’s previous responses, making the interaction more dynamic and relevant. This method works by utilizing a structured output strategy to ensure the LLM’s responses are compatible with the system. 

  I Added AI Chatbot to showcase my abilites as a Software Engineer and AI Engineer, adding AI Chatbot also useful as it may help guest that come to my website have a much more nicer experience and make them interest more in me.
  `
}

// Define tools for OpenAI
const tools: ChatCompletionTool[] = [
  {
    type: "function",
    function: {
      name: "get_kiki_life_data",
      description:
        "Get Ekky Mulia Lasardi (Ekky/Kiki) life data, e.g., educationformal, skills, workformal, freelance, awards, journal, gdgoc.",
      parameters: {
        type: "object",
        properties: {
          data: {
            type: "string",
            description:
              "Pick one: educationformal, skills, workformal, freelance, awards, journal, gdgoc",
            enum: [
              "educationformal",
              "skills",
              "workformal",
              "freelance",
              "awards",
              "journal",
              "gdgoc",
            ],
          },
        },
        required: ["data"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "get_kiki_projects_data",
      description:
        "Get Notable Ekky Mulia Lasardi (Ekky/Kiki) Projects data, e.g., personal, hobby, competition, freelance, work projects.",
      parameters: {
        type: "object",
        properties: {
          data: {
            type: "string",
            description:
              "Pick one: personalhobbycompetitionproject, freelanceworkproject",
            enum: [
              "personalhobbycompetitionproject",
              "freelanceworkproject",
            ],
          },
        },
        required: ["data"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "get_about_kiki",
      description:
        "Get Details of Ekky Mulia Lasardi (Ekky/Kiki) Summary.",
      parameters: {},
    },
  },
  {
    type: "function",
    function: {
      name: "get_website_faq",
      description:
        "Get Details of How do i Make Ekky Mulia Lasardi (Ekky/Kiki) Personal Website, How the AI is being used, why the prompt input is a button choice, what is the different with the other chatbots and OTHER THINGS related to technical about website/ai/chatbot, USE this function",
      parameters: {},
    },
  },
];

const availableFunctions: Record<string, (data: string) => string> = {
  get_kiki_life_data: getKikiLifeData,
  get_kiki_projects_data: getKikiProjectsData,
  get_about_kiki: getAboutKiki,
  get_website_faq: getWebsiteFAQ
};

const ResponseFormatSchema = z.object({
  answer: z.string(),
  followUpQuestion: z.array(z.string()).optional(),
});

// Type for AI messages
interface ToolCall {
  id: string;
  function: {
    name: string;
    arguments: string;
  };
}

// Type predicate to remove null values
function isNotNull<T>(value: T | null): value is T {
  return value !== null;
}

// Function to communicate with OpenAI
interface ResponseFormat extends z.infer<typeof ResponseFormatSchema> {}

export async function askingAI(question: string, retryCount = 3): Promise<ResponseFormat> {
  const messages: ChatCompletionMessageParam[] = [
    {
      role: "system",
      content:
        `You are Kiki Assistant, a personal portfolio assistant for Ekky Mulia Lasardi (Ekky/Kiki). Use the provided data to answer questions, avoiding hallucination or made-up answers. If you don’t have the data, respond with ‘I don’t have that data yet’. For non-personal queries, use general knowledge.

        After answering, provide 4 concise follow-up questions related to the available data in a second POV. Keep responses under 55 words and follow-up questions under 25 words.

        ALWAYS USE TOOLS TO RESPONSE

        ALWAYS RESPONSE IN RESPONSE FORMAT
        const ResponseFormatSchema = z.object({
          answer: z.string(),
          followUpQuestion: z.array(z.string()).optional(),
        });
        `,
    },
    { role: "user", content: question },
  ];

  try {
    const chatCompletion = await client.chat.completions.create({
      messages,
      model: "o3-mini",
      tools,
      tool_choice: "auto",
    });

    const responseMessage = chatCompletion.choices[0]?.message;

    if (responseMessage?.tool_calls) {
      const toolCalls: ToolCall[] = responseMessage.tool_calls;

      messages.push(responseMessage);

      const functionResponses = await Promise.all(
        toolCalls.map(async (toolCall) => {
          try {
            const functionName = toolCall.function.name;
            const functionArgs = JSON.parse(toolCall.function.arguments);
            const functionToCall = availableFunctions[functionName];

            if (functionToCall) {
              const result = functionToCall(functionArgs.data);
              console.log(result);

              return {
                tool_call_id: toolCall.id,
                role: "tool",
                name: functionName,
                content: result,
              } as ChatCompletionMessageParam;
            }
          } catch (error) {
            console.error("Error processing tool call:", error);
          }
          return null;
        })
      );

      // Filter out null values before adding to messages
      messages.push(...functionResponses.filter(isNotNull));

      const secondChatCompletion = await client.chat.completions.create({
        model: "o3-mini",
        messages: messages,
        tools,
        tool_choice: "auto",
        response_format: zodResponseFormat(ResponseFormatSchema, "json"),
      });

      // Parse and return the expected format
      const content = secondChatCompletion.choices[0]?.message?.content || "No response received.";
      try {
        const parsedResponse = JSON.parse(content);
        return ResponseFormatSchema.parse(parsedResponse); // Return the validated object
      } catch (e) {
        console.error("Invalid response format:", e);
        return { answer: "No answer available.", followUpQuestion: [] }; // Default fallback
      }
    }
  } catch (error) {
    console.error("Error in askingAI function:", error);
  }

  // Retry if failure and retryCount > 0
  if (retryCount > 0) {
    console.log(`Retrying... ${retryCount} attempts left.`);
    return askingAI(question, retryCount - 1); // Retry the function
  }

  return { answer: "No answer available.", followUpQuestion: [] }; // Default fallback after retries
}